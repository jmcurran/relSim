# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

.breed <- function(Parents, ns, Ns, nLoci) {
    .Call(`_relSim_breed`, Parents, ns, Ns, nLoci)
}

.calcFst <- function(Pop, SubPopIdx, N, ns, nLoci, NumLocusAlleles) {
    .Call(`_relSim_calcFst`, Pop, SubPopIdx, N, ns, nLoci, NumLocusAlleles)
}

.calcFStatistics <- function(Pop, SubPopIdx, N, ns, nLoci, NumLocusAlleles) {
    .Call(`_relSim_calcFStatistics`, Pop, SubPopIdx, N, ns, nLoci, NumLocusAlleles)
}

.IS <- function(freqs, N, numContributors, maxAllelesShowing, Perms, bTail = FALSE) {
    .Call(`_relSim_IS`, freqs, N, numContributors, maxAllelesShowing, Perms, bTail)
}

.locusLRmix <- function(ProfVic, ProfSus, Freq) {
    .Call(`_relSim_locusLRmix_Caller`, ProfVic, ProfSus, Freq)
}

.LRmix <- function(ProfVic, ProfSus, listFreqs) {
    .Call(`_relSim_LRmix`, ProfVic, ProfSus, listFreqs)
}

.locusIBS <- function(ProfMat, N) {
    .Call(`_relSim_locusIBS`, ProfMat, N)
}

.IBS_Caller <- function(Prof1, Prof2, nLoci) {
    .Call(`_relSim_IBS_Caller`, Prof1, Prof2, nLoci)
}

.randomProfiles <- function(listFreqs, nBlockSize = 1000L) {
    .Call(`_relSim_randomProfiles`, listFreqs, nBlockSize)
}

randomSibs <- function(ProfSib1, listFreqs, nBlockSize) {
    .Call(`_relSim_randomSibs`, ProfSib1, listFreqs, nBlockSize)
}

randomChildren <- function(ProfParent, listFreqs, nBlockSize) {
    .Call(`_relSim_randomChildren`, ProfParent, listFreqs, nBlockSize)
}

.lrPC <- function(ProfParent, ProfChild, listFreqs) {
    .Call(`_relSim_lrPC_Caller`, ProfParent, ProfChild, listFreqs)
}

maximizeLRPC <- function(listFreqs, nBlockSize) {
    .Call(`_relSim_maximizeLRPC`, listFreqs, nBlockSize)
}

.lrSib <- function(ProfSib1, ProfSib2, listFreqs) {
    .Call(`_relSim_lrSib_Caller`, ProfSib1, ProfSib2, listFreqs)
}

blockStatCounts <- function(Prof1, Prof2, nProf, listFreqs, nCode, bFalseNeg, IBSthresh, LRthresh, nNumResults) {
    .Call(`_relSim_blockStatCounts`, Prof1, Prof2, nProf, listFreqs, nCode, bFalseNeg, IBSthresh, LRthresh, nNumResults)
}

blockStats <- function(Prof1, Prof2, nProf, listFreqs, nCode) {
    .Call(`_relSim_blockStats`, Prof1, Prof2, nProf, listFreqs, nCode)
}

.simNpersonMixture <- function(listFreqs, numContributors, numIterations) {
    .Call(`_relSim_simNpersonMixture`, listFreqs, numContributors, numIterations)
}

#' Search a database for siblings or children
#' 
#' This function searches a database of profiles for either a sibling or a child
#' @param profiles an integer vector of stacked profiles representing the database. This vector has \eqn{2NL} entries, where N is the number of
#' profiles and L is the number of loci.
#' @param siblings an integer vector of stacked profiles representing the siblings of the profiles in database. 
#' The first entry is a sibling of the first entry in \code{profiles} and so on. This vector has \eqn{2NL} entries, where N is the number of
#' profiles and L is the number of loci.
#' @param children an integer vector of stacked profiles representing the children of the profiles in database. 
#' The first entry is a child of the first entry in \code{profiles} and so on. This vector has \eqn{2NL} entries, where N is the number of
#' profiles and L is the number of loci.
#' @param listFreqs is a set of allele frequencies representing a particular multiplex. The function assumes that that loci in the profiles
#' are in the same order as the loci in this list. The data structure is a \code{List} of \code{NumericVector}'s.
#' @param step A step size for progress reporting, i.e. print out progress every \code{step} iterations. If \code{step = -1}, then there is no printing.
#' 
#' @return a \code{List} containing two dataframes, one called \code{sibs} and one called \code{children}. Each dataframe has results from searching for
#' either the sibling or the child in the database. For each entry there is a record of which profile gave the highest LR (and its value),
#' and the position of the actual sibling or parent/child in the database (and its respective LR).
#' 
#' @author James Curran
#' @export
famSearch <- function(profiles, siblings, children, listFreqs, step) {
    .Call(`_relSim_famSearch`, profiles, siblings, children, listFreqs, step)
}

#' Compute the likehood ratio for all pairs of profiles in a database
#' 
#' This function takes every pair of profiles in a database of profiles and computes
#' the likelihood ratio (LR) for a specific relationship given by \code{nCode}. That means
#' there will be \eqn{N(N-1)/2} LRs computed for N profiles.
#' @param Profiles an integer vector of stacked profiles representing the database. This vector has \eqn{2NL} entries, where N is the number of
#' profiles and \eqn{L} is the number of loci.
#' @param listFreqs is a set of allele frequencies representing a particular multiplex. The function assumes that that loci in the profiles
#' are in the same order as the loci in this list. The data structure is a \code{List} of \code{NumericVector}'s.
#' @param nCode if \code{1} then compute the LR for siblings, otherwise computer the LR for parent/child.
#' @return a \code{NumericVector} containing the LRs. They are stored in sequential order so if for example there were three
#' profiles, then there are 3 possible LRs, and the result vector would contain the LRs for the profile pairs (1, 2),
#' (1, 3), and (2, 3).
#' 
#' @examples
#' data("USCaucs")
#' N = 600
#' profs = relSim:::.randomProfiles(USCaucs$freqs, N)
#' system.time({lr = relSim:::allPairsLR(profs, USCaucs$freqs, 1)})
#' plot(density(log10(lr)))
#' mean(lr > 1) ## estimate the probability that the LR is incorrectly above 1
#' 
#' @author James Curran
#' @export
allPairsLR <- function(Profiles, listFreqs, nCode) {
    .Call(`_relSim_allPairsLR`, Profiles, listFreqs, nCode)
}

